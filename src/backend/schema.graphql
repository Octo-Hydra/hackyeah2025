enum UserRole {
  USER
  ADMIN
}

type User {
  id: ID!
  name: String!
  email: String!
  role: UserRole!
  reputation: Int
  trustScore: Float
  trustScoreBreakdown: TrustScoreBreakdown
  activeJourney: ActiveJourney
  journeyNotifications: [JourneyNotification!]!
}

type JourneyNotification {
  id: ID!
  incidentId: ID!
  title: String!
  description: String
  kind: IncidentKind
  status: ReportStatus
  lineId: ID
  lineName: String
  delayMinutes: Int
  receivedAt: String!
}

type TrustScoreBreakdown {
  baseScore: Float!
  accuracyBonus: Float!
  highRepBonus: Float!
  validationRate: Float!
  updatedAt: String!
}

type ActiveJourney {
  segments: [PathSegment!]!
  startTime: String!
  expectedEndTime: String!
}

type FavoriteConnection {
  id: ID!
  name: String!
  startStopId: ID!
  endStopId: ID!
}

input ActiveJourneyInput {
  segments: [PathSegmentInput!]!
}

input PathSegmentInput {
  from: SegmentLocationInput!
  to: SegmentLocationInput!
  lineId: ID!
  lineName: String!
  transportType: TransportType!
  departureTime: String!
  arrivalTime: String!
  duration: Int!
}

input SegmentLocationInput {
  stopId: ID!
  stopName: String!
  coordinates: CoordinatesInput!
}

input FavoriteConnectionInput {
  name: String!
  startStopId: ID!
  endStopId: ID!
}

input JourneyNotificationInput {
  incidentId: ID!
  title: String!
  description: String
  kind: IncidentKind
  status: ReportStatus
  lineId: ID
  lineName: String
  delayMinutes: Int
}

type OperationResult {
  success: Boolean!
  message: String
}

type TwoFactorSetup {
  secret: String!
  qrCode: String!
}

type Query {
  me: User
  incidentsByLine(lineId: ID!, transportType: TransportType): [Incident!]!
  lines(transportType: TransportType): [Line!]!
  stops(transportType: TransportType): [Stop!]!
  searchStops(query: String!, limit: Int): [Stop!]!
  findPath(input: FindPathInput!): JourneyPath
  findOptimalJourney(input: FindOptimalJourneyInput!): OptimalJourneyResult!
  admin: AdminQuery!
}

type AdminQuery {
  users(filter: UserFilterInput, pagination: PaginationInput): UserConnection!
  user(id: ID!): User
  incidents(
    filter: IncidentFilterInput
    pagination: PaginationInput
  ): IncidentConnection!
  incident(id: ID!): Incident
  archivedIncidents(
    filter: IncidentFilterInput
    pagination: PaginationInput
  ): IncidentConnection!
  stats: AdminStats!
  lineIncidentStats(lineId: ID!, period: StatsPeriod!): LineIncidentStats!
  lineDelayStats(lineId: ID!, period: StatsPeriod!): LineDelayStats!
  topDelays(
    transportType: TransportType
    period: StatsPeriod!
    limit: Int
  ): [LineDelayRanking!]!
  linesIncidentOverview(period: StatsPeriod!): [LineIncidentOverview!]!
}

type AdminStats {
  totalUsers: Int!
  totalIncidents: Int!
  activeIncidents: Int!
  resolvedIncidents: Int!
  fakeIncidents: Int!
  usersByRole: RoleStats!
  incidentsByKind: [KindStats!]!
  averageReputation: Float!
  averageTrustScore: Float!
}

type RoleStats {
  users: Int!
  moderators: Int!
  admins: Int!
}

type KindStats {
  kind: IncidentKind!
  count: Int!
}

type UserConnection {
  items: [User!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type IncidentConnection {
  items: [Incident!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

input UserFilterInput {
  role: UserRole
  minReputation: Int
  maxReputation: Int
  minTrustScore: Float
  maxTrustScore: Float
  search: String
}

input IncidentFilterInput {
  status: ReportStatus
  kind: IncidentKind
  lineId: ID
  transportType: TransportType
  isFake: Boolean
  reportedBy: ID
  dateFrom: String
  dateTo: String
}

input PaginationInput {
  first: Int
  after: ID
  last: Int
  before: ID
}

type Mutation {
  register(name: String!, email: String!, password: String!): Boolean!
  verifyEmail(token: String!): Boolean!
  resendVerificationEmail(email: String!): Boolean!
  setup2FA: TwoFactorSetup!
  verify2FA(token: String!, secret: String!): Boolean!
  disable2FA: Boolean!

  createReport(input: CreateReportInput!): Incident!
  updateReport(id: ID!, input: UpdateReportInput!): Incident!
  deleteReport(id: ID!): Boolean!
  publishReport(id: ID!): Incident!
  resolveReport(id: ID!, isFake: Boolean): Incident!
  setActiveJourney(input: ActiveJourneyInput!): ActiveJourney
  clearActiveJourney: Boolean!
  addFavoriteConnection(input: FavoriteConnectionInput!): ID!
  removeFavoriteConnection(id: ID!): Boolean!
  upsertJourneyNotification(
    input: JourneyNotificationInput!
  ): JourneyNotification!
  dismissJourneyNotification(id: ID!): Boolean!
  clearJourneyNotifications: Boolean!
  updateProfile(input: UpdateProfileInput!): User!
  admin: AdminMutation!
}

type AdminMutation {
  createUser(input: CreateUserInput!): User!
  updateUser(id: ID!, input: UpdateUserInput!): User!
  deleteUser(id: ID!): Boolean!
  updateUserRole(id: ID!, role: UserRole!): User!
  updateUserReputation(id: ID!, reputation: Int!): User!
  createIncident(input: CreateAdminIncidentInput!): Incident!
  updateIncident(id: ID!, input: UpdateAdminIncidentInput!): Incident!
  deleteIncident(id: ID!): Boolean!
  markIncidentAsFake(id: ID!): Incident!
  restoreIncident(id: ID!): Incident!
  bulkResolveIncidents(ids: [ID!]!): [Incident!]!
  bulkDeleteIncidents(ids: [ID!]!): Boolean!
}

input CreateUserInput {
  name: String!
  email: String!
  password: String!
  role: UserRole!
  reputation: Int
}

input UpdateUserInput {
  name: String
  email: String
  password: String
  role: UserRole
  reputation: Int
}

input UpdateProfileInput {
  name: String
}

input CreateAdminIncidentInput {
  title: String!
  description: String
  kind: IncidentKind!
  status: ReportStatus
  lineIds: [ID!]
  affectedSegment: IncidentSegmentInput
  delayMinutes: Int
}

input UpdateAdminIncidentInput {
  title: String
  description: String
  kind: IncidentKind
  status: ReportStatus
  lineIds: [ID!]
  affectedSegment: IncidentSegmentInput
  delayMinutes: Int
  isFake: Boolean
}

input IncidentSegmentInput {
  startStopId: ID!
  endStopId: ID!
  lineId: ID
}

enum IncidentKind {
  INCIDENT
  NETWORK_FAILURE
  VEHICLE_FAILURE
  ACCIDENT
  TRAFFIC_JAM
  PLATFORM_CHANGES
}

enum TransportType {
  BUS
  RAIL
}

enum ReportStatus {
  DRAFT
  PUBLISHED
  RESOLVED
}

type Incident {
  id: ID!
  title: String!
  description: String
  kind: IncidentKind!
  status: ReportStatus!
  lines: [Line!]
  affectedSegment: IncidentSegment
  delayMinutes: Int
  isFake: Boolean
  reportedBy: ID
  reporter: User
  createdAt: String!
}

type IncidentSegment {
  startStopId: ID!
  endStopId: ID!
  lineId: ID
}

type Line {
  id: ID!
  name: String!
  transportType: TransportType!
}

input CreateReportInput {
  description: String
  kind: IncidentKind!
  status: ReportStatus
  lineIds: [ID!]
  reporterLocation: CoordinatesInput
  delayMinutes: Int
}

input UpdateReportInput {
  description: String
  kind: IncidentKind
  status: ReportStatus
  lineIds: [ID!]
  delayMinutes: Int
}

type Coordinates {
  latitude: Float!
  longitude: Float!
}

input CoordinatesInput {
  latitude: Float!
  longitude: Float!
}

type Stop {
  id: ID!
  name: String!
  coordinates: Coordinates!
  transportType: TransportType!
}

type SegmentLocation {
  stopId: ID!
  stopName: String!
  coordinates: Coordinates!
}

type PathSegment {
  from: SegmentLocation!
  to: SegmentLocation!
  lineId: ID!
  lineName: String!
  transportType: TransportType!
  departureTime: String!
  arrivalTime: String!
  duration: Int!
  hasIncident: Boolean!
  warning: PathWarning
}

type PathWarning {
  fromStop: String
  toStop: String
  lineName: String
  description: String!
  incidentKind: IncidentKind
  severity: String
}

type JourneyPath {
  segments: [PathSegment!]!
  totalDuration: Int!
  departureTime: String!
  arrivalTime: String!
  hasIncidents: Boolean!
}

input FindPathInput {
  from: CoordinatesInput!
  to: CoordinatesInput!
  departureTime: String
}

input FindOptimalJourneyInput {
  fromStopId: ID!
  toStopId: ID!
  departureTime: String
  maxTransfers: Int
  preferredTransportTypes: [TransportType!]
  avoidIncidents: Boolean
}

type OptimalJourneyResult {
  journeys: [Journey!]!
  hasAlternatives: Boolean!
}

type Journey {
  segments: [JourneySegment!]!
  totalDuration: Int!
  totalDistance: Float!
  transferCount: Int!
  hasIncidents: Boolean!
  departureTime: String!
  arrivalTime: String!
  alternativeAvailable: Boolean!
}

type JourneySegment {
  from: SegmentLocation!
  to: SegmentLocation!
  lineId: ID!
  lineName: String!
  transportType: TransportType!
  departureTime: String!
  arrivalTime: String!
  duration: Int!
  hasIncident: Boolean!
  incidentDelay: Int
  incidentSeverity: IncidentSeverity
}

enum IncidentSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

type Subscription {
  incidentCreated(transportType: TransportType): Incident!
  incidentUpdated(transportType: TransportType): Incident!
  lineIncidentUpdates(lineId: ID!): Incident!
  myLinesIncidents(lineIds: [ID!]!): Incident!

  smartIncidentNotifications(userId: ID!): Incident!
}

enum StatsPeriod {
  LAST_24H
  LAST_7D
  LAST_31D
}

type LineIncidentStats {
  lineId: ID!
  lineName: String!
  transportType: TransportType!
  period: StatsPeriod!
  totalIncidents: Int!
  incidentsByKind: [IncidentKindCount!]!
  averageDelayMinutes: Float
  timeline: [IncidentTimelineEntry!]!
}

type IncidentKindCount {
  kind: IncidentKind!
  count: Int!
}

type IncidentTimelineEntry {
  timestamp: String!
  incidentCount: Int!
}

type LineDelayStats {
  lineId: ID!
  lineName: String!
  transportType: TransportType!
  period: StatsPeriod!
  totalDelays: Int!
  averageDelayMinutes: Float!
  maxDelayMinutes: Int!
  minDelayMinutes: Int!
  delayDistribution: [DelayBucket!]!
}

type DelayBucket {
  rangeLabel: String!
  count: Int!
}

type LineDelayRanking {
  rank: Int!
  lineId: ID!
  lineName: String!
  transportType: TransportType!
  totalDelays: Int!
  averageDelayMinutes: Float!
  incidentCount: Int!
}

type LineIncidentOverview {
  lineId: ID!
  lineName: String!
  transportType: TransportType!
  incidentCount: Int!
  lastIncidentTime: String
}

"""
PendingIncident: User reports that haven't been published yet.
Multiple users reporting same incident aggregate into one PendingIncident.
When threshold is met, a real Incident is created and published to WebSocket.
"""
type PendingIncident {
  id: ID!
  kind: IncidentKind!
  description: String
  status: PendingIncidentStatus!

  location: Coordinates!
  lineIds: [ID!]
  lines: [Line!]
  delayMinutes: Int

  reporterIds: [ID!]!
  reporters: [User!]!
  totalReports: Int!
  aggregateReputation: Int!
  thresholdScore: Float!
  thresholdRequired: Float!
  thresholdProgress: Int!
  createdAt: String!
  lastReportAt: String!
  expiresAt: String!
  thresholdMetAt: String

  moderatorNotes: String
}

enum PendingIncidentStatus {
  PENDING
  THRESHOLD_MET
  MANUALLY_APPROVED
  REJECTED
  EXPIRED
}

"""
Result when user submits a report
"""
type SubmitReportResult {
  success: Boolean!
  pendingIncident: PendingIncident!
  message: String!
  isNewReport: Boolean!
  wasPublished: Boolean!
  publishedIncident: Incident
  reputationGained: Int
}

"""
Check if user can submit a report (rate limiting)
"""
type CanSubmitResult {
  canSubmit: Boolean!
  reason: String
  cooldownRemaining: Int
  rateLimitInfo: RateLimitInfo
}

type RateLimitInfo {
  reportsRemaining: RateLimitRemaining!
  violations: Int!
  suspiciousScore: Int!
}

type RateLimitRemaining {
  perMinute: Int!
  perHour: Int!
  perDay: Int!
}

"""
Moderator queue item for manual review
"""
type ModeratorQueueItem {
  id: ID!
  pendingIncident: PendingIncident!
  priority: QueuePriority!
  reason: String!
  createdAt: String!
  assignedTo: User
}

enum QueuePriority {
  HIGH
  MEDIUM
  LOW
}

"""
Result of moderator approval
"""
type ApproveReportResult {
  success: Boolean!
  incident: Incident!
  rewardedUsers: [UserReputationChange!]!
  message: String!
}

type UserReputationChange {
  userId: ID!
  user: User!
  oldReputation: Int!
  newReputation: Int!
  change: Int!
  reason: String!
}

extend type Query {
  canSubmitReport: CanSubmitResult!

  myPendingIncidents: [PendingIncident!]!

  pendingIncident(id: ID!): PendingIncident

  moderatorQueue: [ModeratorQueueItem!]!
  allPendingIncidents(status: PendingIncidentStatus): [PendingIncident!]!
}

extend type Mutation {
  submitIncidentReport(input: SubmitReportInput!): SubmitReportResult!

  moderator: ModeratorMutation!
}

type ModeratorMutation {
  approveReport(pendingIncidentId: ID!, notes: String): ApproveReportResult!

  rejectReport(pendingIncidentId: ID!, reason: String!): Boolean!

  flagUserForSpam(userId: ID!, reason: String!): Boolean!

  resetUserSpamScore(userId: ID!): Boolean!
}

input SubmitReportInput {
  kind: IncidentKind!
  description: String
  reporterLocation: CoordinatesInput!
  lineIds: [ID!]
  delayMinutes: Int
}
