enum UserRole {
  USER
  ADMIN
}

type User {
  id: ID!
  name: String!
  email: String!
  role: UserRole!
  reputation: Int
  trustScore: Float # Dynamic trust score (0.5-2.5), updated by cron
  trustScoreBreakdown: TrustScoreBreakdown
  activeJourney: ActiveJourney
  journeyNotifications: [JourneyNotification!]!
}

type JourneyNotification {
  id: ID!
  incidentId: ID!
  title: String!
  description: String
  kind: IncidentKind
  status: ReportStatus
  lineId: ID
  lineName: String
  delayMinutes: Int
  receivedAt: String!
}

type TrustScoreBreakdown {
  baseScore: Float!
  accuracyBonus: Float!
  highRepBonus: Float!
  validationRate: Float!
  updatedAt: String!
}

type ActiveJourney {
  segments: [PathSegment!]!
  startTime: String!
  expectedEndTime: String!
}

type FavoriteConnection {
  id: ID!
  name: String!
  startStopId: ID!
  endStopId: ID!
}

input ActiveJourneyInput {
  segments: [PathSegmentInput!]!
}

input PathSegmentInput {
  from: SegmentLocationInput!
  to: SegmentLocationInput!
  lineId: ID!
  lineName: String!
  transportType: TransportType!
  departureTime: String!
  arrivalTime: String!
  duration: Int!
}

input SegmentLocationInput {
  stopId: ID!
  stopName: String!
  coordinates: CoordinatesInput!
}

input FavoriteConnectionInput {
  name: String!
  startStopId: ID!
  endStopId: ID!
}

input JourneyNotificationInput {
  incidentId: ID!
  title: String!
  description: String
  kind: IncidentKind
  status: ReportStatus
  lineId: ID
  lineName: String
  delayMinutes: Int
}

# Generic result type for operations
type OperationResult {
  success: Boolean!
  message: String
}

type TwoFactorSetup {
  secret: String!
  qrCode: String!
}

type Query {
  me: User
  # Incidents by line (moved from nested UserQuery)
  incidentsByLine(lineId: ID!, transportType: TransportType): [Incident!]!
  # Transit queries
  lines(transportType: TransportType): [Line!]!
  stops(transportType: TransportType): [Stop!]!
  # Search stops by name
  searchStops(query: String!, limit: Int): [Stop!]!
  findPath(input: FindPathInput!): JourneyPath
  # Optimal path finding with A* and incident awareness
  findOptimalJourney(input: FindOptimalJourneyInput!): OptimalJourneyResult!
  # Admin queries (ADMIN/MODERATOR only)
  admin: AdminQuery!
}

type AdminQuery {
  # User management
  users(filter: UserFilterInput, pagination: PaginationInput): UserConnection!
  user(id: ID!): User
  # Incident management
  incidents(
    filter: IncidentFilterInput
    pagination: PaginationInput
  ): IncidentConnection!
  incident(id: ID!): Incident
  # Archived incidents (RESOLVED status)
  archivedIncidents(
    filter: IncidentFilterInput
    pagination: PaginationInput
  ): IncidentConnection!
  # Statistics
  stats: AdminStats!
  # Reports and analytics
  lineIncidentStats(lineId: ID!, period: StatsPeriod!): LineIncidentStats!
  lineDelayStats(lineId: ID!, period: StatsPeriod!): LineDelayStats!
  topDelays(
    transportType: TransportType
    period: StatsPeriod!
    limit: Int
  ): [LineDelayRanking!]!
  linesIncidentOverview(period: StatsPeriod!): [LineIncidentOverview!]!
}

type AdminStats {
  totalUsers: Int!
  totalIncidents: Int!
  activeIncidents: Int!
  resolvedIncidents: Int!
  fakeIncidents: Int!
  usersByRole: RoleStats!
  incidentsByKind: [KindStats!]!
  averageReputation: Float!
  averageTrustScore: Float!
}

type RoleStats {
  users: Int!
  moderators: Int!
  admins: Int!
}

type KindStats {
  kind: IncidentKind!
  count: Int!
}

type UserConnection {
  items: [User!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type IncidentConnection {
  items: [Incident!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String # First item ID
  endCursor: String # Last item ID
}

input UserFilterInput {
  role: UserRole
  minReputation: Int
  maxReputation: Int
  minTrustScore: Float
  maxTrustScore: Float
  search: String # Search by name or email
}

input IncidentFilterInput {
  status: ReportStatus
  kind: IncidentKind
  lineId: ID
  transportType: TransportType
  isFake: Boolean
  reportedBy: ID
  dateFrom: String
  dateTo: String
}

input PaginationInput {
  first: Int # Number of items to return
  after: ID # User/Incident ID for forward pagination
  last: Int # Number of items to return (backward)
  before: ID # User/Incident ID for backward pagination
}

type Mutation {
  # Auth mutations
  register(name: String!, email: String!, password: String!): Boolean!
  verifyEmail(token: String!): Boolean!
  resendVerificationEmail(email: String!): Boolean!
  setup2FA: TwoFactorSetup!
  verify2FA(token: String!, secret: String!): Boolean!
  disable2FA: Boolean!

  # Incident mutations
  createReport(input: CreateReportInput!): Incident!
  updateReport(id: ID!, input: UpdateReportInput!): Incident!
  deleteReport(id: ID!): Boolean!
  publishReport(id: ID!): Incident!
  resolveReport(id: ID!, isFake: Boolean): Incident! # Close incident as resolved or fake
  # User journey mutations
  setActiveJourney(input: ActiveJourneyInput!): ActiveJourney
  clearActiveJourney: Boolean!
  addFavoriteConnection(input: FavoriteConnectionInput!): ID!
  removeFavoriteConnection(id: ID!): Boolean!
  upsertJourneyNotification(
    input: JourneyNotificationInput!
  ): JourneyNotification!
  dismissJourneyNotification(id: ID!): Boolean!
  clearJourneyNotifications: Boolean!
  # Admin mutations (ADMIN/MODERATOR only)
  admin: AdminMutation!
}

type AdminMutation {
  # User CRUD (ADMIN only)
  createUser(input: CreateUserInput!): User!
  updateUser(id: ID!, input: UpdateUserInput!): User!
  deleteUser(id: ID!): Boolean!
  updateUserRole(id: ID!, role: UserRole!): User!
  updateUserReputation(id: ID!, reputation: Int!): User!
  # Incident management (ADMIN/MODERATOR)
  createIncident(input: CreateAdminIncidentInput!): Incident!
  updateIncident(id: ID!, input: UpdateAdminIncidentInput!): Incident!
  deleteIncident(id: ID!): Boolean!
  markIncidentAsFake(id: ID!): Incident!
  restoreIncident(id: ID!): Incident! # Restore from fake
  bulkResolveIncidents(ids: [ID!]!): [Incident!]!
  bulkDeleteIncidents(ids: [ID!]!): Boolean!
}

input CreateUserInput {
  name: String!
  email: String!
  password: String!
  role: UserRole!
  reputation: Int # Optional, defaults to 100
}

input UpdateUserInput {
  name: String
  email: String
  password: String
  role: UserRole
  reputation: Int
}

input CreateAdminIncidentInput {
  title: String!
  description: String
  kind: IncidentKind!
  status: ReportStatus
  lineIds: [ID!]
  affectedSegment: IncidentSegmentInput
  delayMinutes: Int # Estimated delay in minutes
}

input UpdateAdminIncidentInput {
  title: String
  description: String
  kind: IncidentKind
  status: ReportStatus
  lineIds: [ID!]
  affectedSegment: IncidentSegmentInput
  delayMinutes: Int
  isFake: Boolean
}

input IncidentSegmentInput {
  startStopId: ID!
  endStopId: ID!
  lineId: ID
}

enum IncidentKind {
  INCIDENT # Generic incident (ADMIN only)
  NETWORK_FAILURE # Infrastructure issues (ADMIN only)
  VEHICLE_FAILURE # Vehicle breakdown (ADMIN only)
  ACCIDENT # User can report
  TRAFFIC_JAM # User can report
  PLATFORM_CHANGES # Platform/schedule changes (ADMIN only)
}

enum TransportType {
  BUS
  RAIL
}

enum ReportStatus {
  DRAFT
  PUBLISHED
  RESOLVED
}

type Incident {
  id: ID!
  title: String!
  description: String
  kind: IncidentKind!
  status: ReportStatus!
  lines: [Line!]
  affectedSegment: IncidentSegment
  delayMinutes: Int # Estimated delay in minutes
  isFake: Boolean # True if admin/moderator marked as fake
  reportedBy: ID # User ID who reported (for reputation tracking)
  reporter: User # User who reported (includes dynamic trustScore)
  createdAt: String!
}

type IncidentSegment {
  startStopId: ID!
  endStopId: ID!
  lineId: ID
}

type Line {
  id: ID!
  name: String!
  transportType: TransportType!
}

input CreateReportInput {
  description: String
  kind: IncidentKind!
  status: ReportStatus
  lineIds: [ID!]
  reporterLocation: CoordinatesInput # REQUIRED for regular users (USER role), optional for MODERATOR/ADMIN
  delayMinutes: Int # Estimated delay in minutes
}

input UpdateReportInput {
  description: String
  kind: IncidentKind
  status: ReportStatus
  lineIds: [ID!]
  delayMinutes: Int
}

# Geographic coordinates
type Coordinates {
  latitude: Float!
  longitude: Float!
}

input CoordinatesInput {
  latitude: Float!
  longitude: Float!
}

type Stop {
  id: ID!
  name: String!
  coordinates: Coordinates!
  transportType: TransportType!
}

type SegmentLocation {
  stopId: ID!
  stopName: String!
  coordinates: Coordinates!
}

type PathSegment {
  from: SegmentLocation!
  to: SegmentLocation!
  lineId: ID!
  lineName: String!
  transportType: TransportType!
  departureTime: String!
  arrivalTime: String!
  duration: Int!
  hasIncident: Boolean!
  warning: PathWarning # Warning for this specific segment
}

type PathWarning {
  fromStop: String
  toStop: String
  lineName: String
  description: String!
  incidentKind: IncidentKind
  severity: String
}

type JourneyPath {
  segments: [PathSegment!]!
  totalDuration: Int!
  departureTime: String!
  arrivalTime: String!
  hasIncidents: Boolean!
}

input FindPathInput {
  from: CoordinatesInput!
  to: CoordinatesInput!
  departureTime: String
}

# A* Pathfinding with incident awareness
input FindOptimalJourneyInput {
  fromStopId: ID!
  toStopId: ID!
  departureTime: String # ISO datetime, defaults to now
  maxTransfers: Int # Default: 3
  preferredTransportTypes: [TransportType!] # Optional: prefer specific types
  avoidIncidents: Boolean # Default: true - factor in incident delays
}

type OptimalJourneyResult {
  journeys: [Journey!]! # Top 3 routes sorted by optimal time
  hasAlternatives: Boolean!
}

type Journey {
  segments: [JourneySegment!]!
  totalDuration: Int! # Total journey time in minutes
  totalDistance: Float! # Total distance in km
  transferCount: Int! # Number of line changes
  hasIncidents: Boolean! # Any incidents on this route
  departureTime: String! # ISO datetime
  arrivalTime: String! # ISO datetime
  alternativeAvailable: Boolean! # True if other routes exist
}

type JourneySegment {
  from: SegmentLocation!
  to: SegmentLocation!
  lineId: ID!
  lineName: String!
  transportType: TransportType!
  departureTime: String! # ISO datetime
  arrivalTime: String! # ISO datetime
  duration: Int! # Segment duration in minutes
  hasIncident: Boolean! # Incident on this segment
  incidentDelay: Int # Additional delay from incident (minutes)
  incidentSeverity: IncidentSeverity # Severity level
}

enum IncidentSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

type Subscription {
  incidentCreated(transportType: TransportType): Incident!
  incidentUpdated(transportType: TransportType): Incident!
  lineIncidentUpdates(lineId: ID!): Incident!
  myLinesIncidents(lineIds: [ID!]!): Incident!
  # Smart notifications with deduplication and trust-based filtering
  smartIncidentNotifications(userId: ID!): Incident!
}

# Admin-only analytics types
enum StatsPeriod {
  LAST_24H
  LAST_7D
  LAST_31D
}

type LineIncidentStats {
  lineId: ID!
  lineName: String!
  transportType: TransportType!
  period: StatsPeriod!
  totalIncidents: Int!
  incidentsByKind: [IncidentKindCount!]!
  averageDelayMinutes: Float # Average delay when incidents occurred
  timeline: [IncidentTimelineEntry!]! # Incidents over time
}

type IncidentKindCount {
  kind: IncidentKind!
  count: Int!
}

type IncidentTimelineEntry {
  timestamp: String! # ISO date
  incidentCount: Int!
}

type LineDelayStats {
  lineId: ID!
  lineName: String!
  transportType: TransportType!
  period: StatsPeriod!
  totalDelays: Int! # Number of delay incidents
  averageDelayMinutes: Float!
  maxDelayMinutes: Int!
  minDelayMinutes: Int!
  delayDistribution: [DelayBucket!]! # Histogram
}

type DelayBucket {
  rangeLabel: String! # e.g., "0-5 min", "5-15 min", "15-30 min", "30+ min"
  count: Int!
}

type LineDelayRanking {
  rank: Int!
  lineId: ID!
  lineName: String!
  transportType: TransportType!
  totalDelays: Int! # Frequency of delays
  averageDelayMinutes: Float!
  incidentCount: Int! # Total incidents causing delays
}

type LineIncidentOverview {
  lineId: ID!
  lineName: String!
  transportType: TransportType!
  incidentCount: Int!
  lastIncidentTime: String # ISO date of most recent incident
}
