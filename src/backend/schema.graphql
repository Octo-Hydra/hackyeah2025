enum UserRole {
  USER
  MODERATOR
  ADMIN
}

type User {
  id: ID!
  name: String!
  email: String!
  role: UserRole!
  reputation: Int
  trustScore: Float # Dynamic trust score (0.5-2.5), updated by cron
  trustScoreBreakdown: TrustScoreBreakdown
  activeJourney: ActiveJourney
}

type TrustScoreBreakdown {
  baseScore: Float!
  accuracyBonus: Float!
  highRepBonus: Float!
  validationRate: Float!
  updatedAt: String!
}

type ActiveJourney {
  segments: [PathSegment!]!
  startTime: String!
  expectedEndTime: String!
}

type FavoriteConnection {
  id: ID!
  name: String!
  startStopId: ID!
  endStopId: ID!
}

input ActiveJourneyInput {
  segments: [PathSegmentInput!]!
}

input PathSegmentInput {
  from: SegmentLocationInput!
  to: SegmentLocationInput!
  lineId: ID!
  lineName: String!
  transportType: TransportType!
  departureTime: String!
  arrivalTime: String!
  duration: Int!
}

input SegmentLocationInput {
  stopId: ID!
  stopName: String!
  coordinates: CoordinatesInput!
}

input FavoriteConnectionInput {
  name: String!
  startStopId: ID!
  endStopId: ID!
}

# Generic result type for operations
type OperationResult {
  success: Boolean!
  message: String
}

type TwoFactorSetup {
  secret: String!
  qrCode: String!
}

type Query {
  me: User
  # Incidents by line (moved from nested UserQuery)
  incidentsByLine(lineId: ID!, transportType: TransportType): [Incident!]!
  # Transit queries
  lines(transportType: TransportType): [Line!]!
  stops(transportType: TransportType): [Stop!]!
  findPath(input: FindPathInput!): JourneyPath
}

type Mutation {
  # Auth mutations
  register(name: String!, email: String!, password: String!): Boolean!
  verifyEmail(token: String!): Boolean!
  resendVerificationEmail(email: String!): Boolean!
  setup2FA: TwoFactorSetup!
  verify2FA(token: String!, secret: String!): Boolean!
  disable2FA: Boolean!

  # Incident mutations
  createReport(input: CreateReportInput!): Incident!
  updateReport(id: ID!, input: UpdateReportInput!): Incident!
  deleteReport(id: ID!): Boolean!
  publishReport(id: ID!): Incident!
  resolveReport(id: ID!, isFake: Boolean): Incident! # Close incident as resolved or fake
  # User journey mutations
  setActiveJourney(input: ActiveJourneyInput!): ActiveJourney
  clearActiveJourney: Boolean!
  addFavoriteConnection(input: FavoriteConnectionInput!): ID!
  removeFavoriteConnection(id: ID!): Boolean!
}

enum IncidentKind {
  INCIDENT # Generic incident (MODERATOR/ADMIN only)
  NETWORK_FAILURE # Infrastructure issues (MODERATOR/ADMIN only)
  VEHICLE_FAILURE # Vehicle breakdown (MODERATOR/ADMIN only)
  ACCIDENT # User can report
  TRAFFIC_JAM # User can report
  PLATFORM_CHANGES # Platform/schedule changes (MODERATOR/ADMIN only)
}

enum TransportType {
  BUS
  RAIL
}

enum ReportStatus {
  DRAFT
  PUBLISHED
  RESOLVED
}

type Incident {
  id: ID!
  title: String!
  description: String
  kind: IncidentKind!
  status: ReportStatus!
  lines: [Line!]
  affectedSegment: IncidentSegment
  isFake: Boolean # True if admin/moderator marked as fake
  reportedBy: ID # User ID who reported (for reputation tracking)
  reporter: User # User who reported (includes dynamic trustScore)
  createdAt: String!
}

type IncidentSegment {
  startStopId: ID!
  endStopId: ID!
  lineId: ID
}

type Line {
  id: ID!
  name: String!
  transportType: TransportType!
}

input CreateReportInput {
  description: String
  kind: IncidentKind!
  status: ReportStatus
  lineIds: [ID!]
  reporterLocation: CoordinatesInput # REQUIRED for regular users (USER role), optional for MODERATOR/ADMIN
}

input UpdateReportInput {
  description: String
  kind: IncidentKind
  status: ReportStatus
  lineIds: [ID!]
}

# Geographic coordinates
type Coordinates {
  latitude: Float!
  longitude: Float!
}

input CoordinatesInput {
  latitude: Float!
  longitude: Float!
}

type Stop {
  id: ID!
  name: String!
  coordinates: Coordinates!
  transportType: TransportType!
}

type SegmentLocation {
  stopId: ID!
  stopName: String!
  coordinates: Coordinates!
}

type PathSegment {
  from: SegmentLocation!
  to: SegmentLocation!
  lineId: ID!
  lineName: String!
  transportType: TransportType!
  departureTime: String!
  arrivalTime: String!
  duration: Int!
  hasIncident: Boolean!
}

type JourneyPath {
  segments: [PathSegment!]!
  totalDuration: Int!
  departureTime: String!
  arrivalTime: String!
  warnings: [String!]!
  hasIncidents: Boolean!
}

input FindPathInput {
  from: CoordinatesInput!
  to: CoordinatesInput!
  departureTime: String
}

type Subscription {
  incidentCreated(transportType: TransportType): Incident!
  incidentUpdated(transportType: TransportType): Incident!
  lineIncidentUpdates(lineId: ID!): Incident!
  myLinesIncidents(lineIds: [ID!]!): Incident!
  # Smart notifications with deduplication and trust-based filtering
  smartIncidentNotifications(userId: ID!): Incident!
}
