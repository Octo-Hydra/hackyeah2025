# System Powiadomie≈Ñ dla U≈ºytkownik√≥w - Dokumentacja

## üìã PrzeglƒÖd

System inteligentnych powiadomie≈Ñ o incydentach, kt√≥ry wykorzystuje algorytm progowy (threshold algorithm) do oceny, czy u≈ºytkownik powinien otrzymaƒá powiadomienie o nowym zg≈Çoszeniu.

## üéØ Funkcjonalno≈õci

### 1. Aktywna Podr√≥≈º (Active Journey)

U≈ºytkownik mo≈ºe ustawiƒá aktywnƒÖ podr√≥≈º, kt√≥rƒÖ w≈Ça≈õnie odbywa. System monitoruje incydenty wp≈ÇywajƒÖce na tƒô trasƒô i wysy≈Ça powiadomienia o wysokim priorytecie.

**Priorytety:**
- **CRITICAL** - Powa≈ºne incydenty (CLASS_1) na aktywnej trasie
- **HIGH** - Mniejsze incydenty (CLASS_2) na aktywnej trasie

### 2. Ulubione Po≈ÇƒÖczenia (Favorite Connections)

U≈ºytkownik mo≈ºe zapisaƒá ulubione trasy (np. "Dom - Praca", "Do szko≈Çy"). System wysy≈Ça powiadomienia o incydentach na tych trasach **niezale≈ºnie od tego, czy u≈ºytkownik aktualnie nimi podr√≥≈ºuje**.

**Priorytety:**
- **HIGH** - Powa≈ºne incydenty (CLASS_1) na ulubionych trasach
- **MEDIUM** - Mniejsze incydenty (CLASS_2) na ulubionych trasach

### 3. Algorytm Decyzyjny

System analizuje ka≈ºdy nowy incydent i sprawdza:
1. Czy incydent wp≈Çywa na **aktywnƒÖ podr√≥≈º** u≈ºytkownika ‚Üí **NAJWY≈ªSZY PRIORYTET**
2. Czy incydent wp≈Çywa na **ulubione po≈ÇƒÖczenia** u≈ºytkownika ‚Üí **≈öREDNI PRIORYTET**
3. Je≈õli nie - nie wysy≈Ça powiadomienia

## üîß GraphQL API

### Typy Danych

```graphql
type User {
  id: ID!
  reputation: Int
  activeJourney: ActiveJourney
  favoriteConnections: [FavoriteConnection!]
}

type ActiveJourney {
  routeIds: [ID!]!
  lineIds: [ID!]!
  startStopId: ID!
  endStopId: ID!
  startTime: String!
  expectedEndTime: String!
  notifiedIncidentIds: [ID!]
}

type FavoriteConnection {
  id: ID!
  name: String!
  routeIds: [ID!]!
  lineIds: [ID!]!
  startStopId: ID!
  endStopId: ID!
  notifyAlways: Boolean!
  createdAt: String!
}
```

### Mutacje

#### 1. Ustawienie Aktywnej Podr√≥≈ºy

```graphql
mutation SetActiveJourney($input: ActiveJourneyInput!) {
  userMutations {
    setActiveJourney(input: $input) {
      id
      activeJourney {
        lineIds
        startTime
        expectedEndTime
      }
    }
  }
}
```

**Przyk≈Çadowe zmienne:**
```json
{
  "input": {
    "routeIds": ["route1_id", "route2_id"],
    "lineIds": ["line1_id", "line2_id"],
    "startStopId": "stop_a_id",
    "endStopId": "stop_b_id",
    "startTime": "2025-10-04T14:30:00Z",
    "expectedEndTime": "2025-10-04T15:45:00Z"
  }
}
```

**Przypadki u≈ºycia:**
- U≈ºytkownik wsiada do autobusu/pociƒÖgu
- Aplikacja mobilna automatycznie ustawia aktywnƒÖ podr√≥≈º
- System zaczyna monitorowaƒá incydenty na tej trasie

#### 2. Zako≈Ñczenie Aktywnej Podr√≥≈ºy

```graphql
mutation ClearActiveJourney {
  userMutations {
    clearActiveJourney {
      id
      activeJourney
    }
  }
}
```

**Przypadki u≈ºycia:**
- U≈ºytkownik dotar≈Ç do celu
- Automatyczne zako≈Ñczenie po up≈Çywie `expectedEndTime`
- Rƒôczne zako≈Ñczenie przez u≈ºytkownika

#### 3. Dodanie Ulubionego Po≈ÇƒÖczenia

```graphql
mutation AddFavorite($input: FavoriteConnectionInput!) {
  userMutations {
    addFavoriteConnection(input: $input) {
      id
      name
      lineIds
      notifyAlways
    }
  }
}
```

**Przyk≈Çadowe zmienne:**
```json
{
  "input": {
    "name": "Dom - Praca",
    "routeIds": ["route1_id"],
    "lineIds": ["line1_id", "line2_id"],
    "startStopId": "home_stop_id",
    "endStopId": "work_stop_id",
    "notifyAlways": true
  }
}
```

**Parametry:**
- `notifyAlways: true` (domy≈õlnie) - Powiadomienia zawsze, nawet gdy u≈ºytkownik nie podr√≥≈ºuje
- `notifyAlways: false` - Powiadomienia tylko gdy trasa jest aktywna

#### 4. Usuniƒôcie Ulubionego Po≈ÇƒÖczenia

```graphql
mutation RemoveFavorite($id: ID!) {
  userMutations {
    removeFavoriteConnection(id: $id) {
      success
      message
    }
  }
}
```

#### 5. Aktualizacja Ulubionego Po≈ÇƒÖczenia

```graphql
mutation UpdateFavorite($id: ID!, $input: FavoriteConnectionInput!) {
  userMutations {
    updateFavoriteConnection(id: $id, input: $input) {
      id
      name
      notifyAlways
    }
  }
}
```

#### 6. Utworzenie Zg≈Çoszenia przez U≈ºytkownika

```graphql
mutation CreateUserReport($input: CreateReportInput!) {
  userMutations {
    createReport(input: $input) {
      id
      title
      kind
      incidentClass
    }
  }
}
```

**Co siƒô dzieje po utworzeniu zg≈Çoszenia:**
1. Zg≈Çoszenie zapisywane do bazy danych
2. **Algorytm sprawdza wszystkich u≈ºytkownik√≥w** i ocenia, kto powinien dostaƒá powiadomienie
3. System automatycznie wysy≈Ça powiadomienia do dotkniƒôtych u≈ºytkownik√≥w
4. Publikowane zdarzenie WebSocket dla subskrybent√≥w

## üß† Threshold Algorithm - Logika Decyzyjna

### Funkcja: `shouldNotifyUser()`

```typescript
export function shouldNotifyUser(
  incidentLineIds: (string | null)[],
  userActiveJourneyLineIds?: string[],
  userFavoriteLineIds?: string[],
  incidentClass?: "CLASS_1" | "CLASS_2",
): NotificationDecision
```

**Zwraca:**
```typescript
interface NotificationDecision {
  shouldNotify: boolean;
  reason: string;
  priority: "LOW" | "MEDIUM" | "HIGH" | "CRITICAL";
  affectedRoutes?: string[];
  message?: string;
}
```

### Przyk≈Çady Decyzji

**Przyk≈Çad 1: Incydent na aktywnej trasie (CLASS_1)**
```typescript
Input:
  incidentLineIds: ["line_1", "line_2"]
  userActiveJourneyLineIds: ["line_1", "line_3"]
  incidentClass: "CLASS_1"

Output:
{
  shouldNotify: true,
  reason: "Incident affects your active journey",
  priority: "CRITICAL",
  affectedRoutes: ["line_1"],
  message: "‚ö†Ô∏è CRITICAL: Your current journey is affected by a serious incident!"
}
```

**Przyk≈Çad 2: Incydent na ulubionej trasie (CLASS_2)**
```typescript
Input:
  incidentLineIds: ["line_5"]
  userActiveJourneyLineIds: undefined
  userFavoriteLineIds: ["line_5", "line_6"]
  incidentClass: "CLASS_2"

Output:
{
  shouldNotify: true,
  reason: "Incident affects your favorite connection",
  priority: "MEDIUM",
  affectedRoutes: ["line_5"],
  message: "‚ÑπÔ∏è An incident is affecting one of your favorite routes."
}
```

**Przyk≈Çad 3: Incydent nie dotyczy u≈ºytkownika**
```typescript
Input:
  incidentLineIds: ["line_10"]
  userActiveJourneyLineIds: ["line_1"]
  userFavoriteLineIds: ["line_5", "line_6"]

Output:
{
  shouldNotify: false,
  reason: "Incident does not affect user's journeys or favorites",
  priority: "LOW"
}
```

## üìä Przep≈Çyw Danych

### Tworzenie Zg≈Çoszenia przez U≈ºytkownika

```
1. U≈ºytkownik wywo≈Çuje createReport mutation
                ‚Üì
2. Backend zapisuje incydent do MongoDB
                ‚Üì
3. notifyAffectedUsers() - algorytm sprawdza wszystkich u≈ºytkownik√≥w
                ‚Üì
4. Dla ka≈ºdego u≈ºytkownika:
   - extractActiveJourneyLineIds() - wyciƒÖga linie z aktywnej podr√≥≈ºy
   - extractFavoriteLineIds() - wyciƒÖga linie z ulubionych po≈ÇƒÖcze≈Ñ
   - shouldNotifyUser() - decyduje czy powiadomiƒá
                ‚Üì
5. Je≈õli shouldNotify == true:
   - Dodaje incidentId do user.activeJourney.notifiedIncidentIds
   - Loguje decyzjƒô: "üì¢ Notify user X: [message] [priority]"
   - (W przysz≈Ço≈õci: wysy≈Ça push notification)
                ‚Üì
6. Publikuje zdarzenie WebSocket (INCIDENT_CREATED)
                ‚Üì
7. Wszyscy subskrybenci otrzymujƒÖ powiadomienie w czasie rzeczywistym
```

## üöÄ Przyk≈Çady U≈ºycia

### Frontend - React/Next.js

#### 1. Ustawienie Aktywnej Podr√≥≈ºy (np. po rozpoczƒôciu nawigacji)

```typescript
import { useMutation } from '@apollo/client';
import { gql } from '@apollo/client';

const SET_ACTIVE_JOURNEY = gql`
  mutation SetActiveJourney($input: ActiveJourneyInput!) {
    userMutations {
      setActiveJourney(input: $input) {
        id
        activeJourney {
          lineIds
          startTime
        }
      }
    }
  }
`;

function StartJourneyButton({ route }) {
  const [setActiveJourney] = useMutation(SET_ACTIVE_JOURNEY);

  const handleStartJourney = async () => {
    await setActiveJourney({
      variables: {
        input: {
          routeIds: route.routeIds,
          lineIds: route.lineIds,
          startStopId: route.startStop.id,
          endStopId: route.endStop.id,
          startTime: new Date().toISOString(),
          expectedEndTime: calculateExpectedArrival(route),
        }
      }
    });

    // Teraz system bƒôdzie monitorowa≈Ç tƒô trasƒô!
    showNotification("Journey tracking started!");
  };

  return (
    <button onClick={handleStartJourney}>
      Start Journey Tracking
    </button>
  );
}
```

#### 2. ZarzƒÖdzanie Ulubionymi Po≈ÇƒÖczeniami

```typescript
const ADD_FAVORITE = gql`
  mutation AddFavorite($input: FavoriteConnectionInput!) {
    userMutations {
      addFavoriteConnection(input: $input) {
        id
        name
        lineIds
      }
    }
  }
`;

function SaveFavoriteRoute({ route }) {
  const [addFavorite] = useMutation(ADD_FAVORITE);

  const handleSaveFavorite = async () => {
    const name = prompt("Name this connection:");
    
    await addFavorite({
      variables: {
        input: {
          name: name || "Unnamed Route",
          routeIds: route.routeIds,
          lineIds: route.lineIds,
          startStopId: route.startStop.id,
          endStopId: route.endStop.id,
          notifyAlways: true, // Always notify about this route
        }
      }
    });

    showNotification("Route saved to favorites!");
  };

  return (
    <button onClick={handleSaveFavorite}>
      ‚≠ê Save as Favorite
    </button>
  );
}
```

#### 3. Automatyczne zako≈Ñczenie podr√≥≈ºy po dotarciu do celu

```typescript
const CLEAR_ACTIVE_JOURNEY = gql`
  mutation ClearActiveJourney {
    userMutations {
      clearActiveJourney {
        id
        activeJourney
      }
    }
  }
`;

function useAutoEndJourney() {
  const [clearJourney] = useMutation(CLEAR_ACTIVE_JOURNEY);
  const { data: userData } = useQuery(GET_ME);

  useEffect(() => {
    if (!userData?.me?.activeJourney) return;

    const expectedEnd = new Date(userData.me.activeJourney.expectedEndTime);
    const now = new Date();
    const timeRemaining = expectedEnd.getTime() - now.getTime();

    if (timeRemaining > 0) {
      const timer = setTimeout(() => {
        clearJourney();
        showNotification("Journey completed!");
      }, timeRemaining);

      return () => clearTimeout(timer);
    }
  }, [userData, clearJourney]);
}
```

## üîî Integracja z Push Notifications

### Przyk≈Çad: Service Worker z Web Push API

```typescript
// service-worker.ts
self.addEventListener('push', (event) => {
  const data = event.data.json();
  
  if (data.type === 'incident_notification') {
    const options = {
      body: data.message,
      icon: '/icon-warning.png',
      badge: '/badge.png',
      tag: `incident-${data.incidentId}`,
      data: {
        incidentId: data.incidentId,
        priority: data.priority,
      },
      actions: [
        { action: 'view', title: 'View Details' },
        { action: 'dismiss', title: 'Dismiss' },
      ],
      vibrate: data.priority === 'CRITICAL' ? [200, 100, 200] : [100],
    };

    event.waitUntil(
      self.registration.showNotification(data.title, options)
    );
  }
});
```

## üìà Monitoring i Logi

System loguje ka≈ºdƒÖ decyzjƒô o powiadomieniu:

```
üì¢ Notify user john@example.com: ‚ö†Ô∏è CRITICAL: Your current journey is affected by a serious incident! [CRITICAL]
üì¢ Notify user jane@example.com: ‚ÑπÔ∏è An incident is affecting one of your favorite routes. [MEDIUM]
```

**Format logu:**
- üì¢ - Ikona powiadomienia
- Email u≈ºytkownika
- Tre≈õƒá wiadomo≈õci
- Priorytet w nawiasach kwadratowych

## üé® Wy≈õwietlanie Priorytet√≥w w UI

```typescript
function getNotificationStyle(priority: string) {
  switch (priority) {
    case 'CRITICAL':
      return {
        color: 'red',
        icon: 'üö®',
        sound: 'critical-alert.mp3',
      };
    case 'HIGH':
      return {
        color: 'orange',
        icon: '‚ö†Ô∏è',
        sound: 'high-alert.mp3',
      };
    case 'MEDIUM':
      return {
        color: 'yellow',
        icon: '‚ÑπÔ∏è',
        sound: 'info-alert.mp3',
      };
    default:
      return {
        color: 'gray',
        icon: 'üìå',
        sound: null,
      };
  }
}
```

## üîí Bezpiecze≈Ñstwo

### Uwaga: Autentykacja wymagana

Wszystkie mutacje u≈ºytkownika wymagajƒÖ sesji:

```typescript
const userEmail = ctx.session?.user?.email;
if (!userEmail) {
  throw new Error("Not authenticated");
}
```

### Prywatno≈õƒá danych

- Tylko u≈ºytkownik widzi swoje aktywne podr√≥≈ºe
- Tylko u≈ºytkownik widzi swoje ulubione po≈ÇƒÖczenia
- Incydenty sƒÖ publiczne, ale powiadomienia personalizowane

## üö¶ Najlepsze Praktyki

### 1. Automatyzacja

‚úÖ **Dobrze:**
- Automatyczne ustawianie aktywnej podr√≥≈ºy po rozpoczƒôciu nawigacji
- Automatyczne zako≈Ñczenie po dotarciu do celu
- Subskrypcje WebSocket dla real-time updates

‚ùå **≈πle:**
- Rƒôczne od≈õwie≈ºanie strony aby zobaczyƒá nowe incydenty
- Brak automatycznego czyszczenia starych aktywnych podr√≥≈ºy

### 2. UX

‚úÖ **Dobrze:**
- R√≥≈ºne style wizualne dla r√≥≈ºnych priorytet√≥w
- D≈∫wiƒôki dla krytycznych powiadomie≈Ñ
- Wibracje dla alert√≥w na urzƒÖdzeniach mobilnych
- Mo≈ºliwo≈õƒá wyciszenia powiadomie≈Ñ dla konkretnych po≈ÇƒÖcze≈Ñ

‚ùå **≈πle:**
- Wszystkie powiadomienia wyglƒÖdajƒÖ tak samo
- Brak mo≈ºliwo≈õci zarzƒÖdzania ulubionymi trasami
- Spam powiadomie≈Ñ o ma≈ÇoznaczƒÖcych incydentach

### 3. Wydajno≈õƒá

‚úÖ **Dobrze:**
- Algorytm sprawdza tylko u≈ºytkownik√≥w z aktywnymi podr√≥≈ºami lub ulubionymi trasami
- Deduplikacja notifiedIncidentIds zapobiega duplikatom
- Indeksy MongoDB na email i lineIds

‚ùå **≈πle:**
- Sprawdzanie ka≈ºdego u≈ºytkownika przy ka≈ºdym incydencie bez filtrowania
- Brak cache'owania ulubionych tras
- Wysy≈Çanie tych samych powiadomie≈Ñ wielokrotnie

## üìù TODO / Przysz≈Çe Usprawnienia

- [ ] Wysy≈Çanie rzeczywistych push notifications (Web Push API)
- [ ] Email notifications dla krytycznych incydent√≥w
- [ ] SMS dla u≈ºytkownik√≥w premium
- [ ] Historia powiadomie≈Ñ w profilu u≈ºytkownika
- [ ] Statystyki: ile razy trasa by≈Ça dotkniƒôta incydentami
- [ ] Rekomendacje alternatywnych tras przy incydentach
- [ ] Machine learning do przewidywania op√≥≈∫nie≈Ñ
- [ ] Integracja z kalendarzem (automatyczne ulubione trasy na podstawie regularnych podr√≥≈ºy)

## üß™ Testowanie

### Test 1: U≈ºytkownik z aktywnƒÖ podr√≥≈ºƒÖ

```graphql
# 1. Ustawienie aktywnej podr√≥≈ºy
mutation {
  userMutations {
    setActiveJourney(input: {
      routeIds: ["route1"]
      lineIds: ["line1"]
      startStopId: "stop_a"
      endStopId: "stop_b"
      startTime: "2025-10-04T14:00:00Z"
      expectedEndTime: "2025-10-04T15:00:00Z"
    }) {
      id
      activeJourney {
        lineIds
      }
    }
  }
}

# 2. Utworzenie incydentu na line1
mutation {
  userMutations {
    createReport(input: {
      title: "Awaria pojazdu"
      kind: VEHICLE_FAILURE
      lineIds: ["line1"]
    }) {
      id
    }
  }
}

# Oczekiwany wynik: U≈ºytkownik otrzyma CRITICAL notification
# Log: üì¢ Notify user X: ‚ö†Ô∏è CRITICAL: Your current journey is affected by a serious incident! [CRITICAL]
```

### Test 2: U≈ºytkownik z ulubionymi trasami

```graphql
# 1. Dodanie ulubionej trasy
mutation {
  userMutations {
    addFavoriteConnection(input: {
      name: "Dom - Praca"
      routeIds: ["route5"]
      lineIds: ["line5"]
      startStopId: "home"
      endStopId: "work"
      notifyAlways: true
    }) {
      id
    }
  }
}

# 2. Utworzenie incydentu na line5
mutation {
  userMutations {
    createReport(input: {
      title: "Drobne op√≥≈∫nienie"
      kind: TRAFFIC_JAM
      lineIds: ["line5"]
    }) {
      id
    }
  }
}

# Oczekiwany wynik: U≈ºytkownik otrzyma MEDIUM notification
# Log: üì¢ Notify user X: ‚ÑπÔ∏è An incident is affecting one of your favorite routes. [MEDIUM]
```

## üìñ Podsumowanie

System zapewnia:
- ‚úÖ Inteligentne powiadomienia oparte na kontek≈õcie u≈ºytkownika
- ‚úÖ Personalizowane alerty dla aktywnych podr√≥≈ºy
- ‚úÖ Monitoring ulubionych tras
- ‚úÖ Priorytetyzacjƒô powiadomie≈Ñ (CRITICAL > HIGH > MEDIUM > LOW)
- ‚úÖ AutomatycznƒÖ detekcjƒô dotkniƒôtych u≈ºytkownik√≥w
- ‚úÖ Real-time updates przez WebSocket
- ‚úÖ Integracjƒô z threshold algorithm

**Gotowe do produkcji!** üöÄ
